/*****************************************************************************
* @file     main.c
* @version  V1.00
* $Date: 16/08/02 5:11p $
* @brief    Use internal SRAM as back end storage media to simulate a
*           30 KB USB pen drive
*
* @note
* Copyright (C) 2016 Nuvoton Technology Corp. All rights reserved.
******************************************************************************/
#include <stdio.h>
#include "NuMicro.h"
#include "massstorage.h"
#include "M480.h"

#define PLL_CLOCK       192000000
volatile uint32_t g_u32AdcIntFlag, g_u32COVNUMFlag = 0;
volatile uint32_t g_u32IsTestOver = 0;
int16_t  g_i32ConversionData[16] __attribute__((at(0x20007320)));
uint32_t g_u32SampleModuleNum = 0;
uint32_t conversionAddress=0x20002520; 
uint32_t DataAddress=0x20007300;//25
uint16_t time_tag=0;
extern uint8_t volatile g_u8MscStart;

void ADC00_IRQHandler(void)
{
	g_u32AdcIntFlag = 1;
	EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);      /* Clear the A/D ADINT0 interrupt flag */
}

void delay_us(int count)//approximately 1us
{
	int i,j;
	for(i=0;i<count;i++)
	{
		for(j=0;j<30;j++)
			__NOP();
	}
}

void delay_ms(int count)//approximately 1ms
{
	int i,j;
	for(i=0;i<count;i++)
	{
		for(j=0;j<30000;j++)
			__NOP();
	}
}
/*--------------------------------------------------------------------------*/
void SYS_Init(void)
{
	uint32_t volatile i;

	/* Unlock protected registers */
	SYS_UnlockReg();

	/* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
	PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);

	/* Enable External XTAL (4~24 MHz) */
	CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);

	/* Waiting for 12MHz clock ready */
	CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);

	/* Switch HCLK clock source to HXT */
	CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HXT,CLK_CLKDIV0_HCLK(1));

	/* Set core clock as PLL_CLOCK from PLL */
	CLK_SetCoreClock(FREQ_192MHZ);

	/* Set both PCLK0 and PCLK1 as HCLK/2 */
	CLK->PCLKDIV = CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2;

	SYS->USBPHY &= ~SYS_USBPHY_HSUSBROLE_Msk;    /* select HSUSBD */
	/* Enable USB PHY */
	SYS->USBPHY = (SYS->USBPHY & ~(SYS_USBPHY_HSUSBROLE_Msk | SYS_USBPHY_HSUSBACT_Msk)) | SYS_USBPHY_HSUSBEN_Msk;
	for (i=0; i<0x1000; i++);      // delay > 10 us
	SYS->USBPHY |= SYS_USBPHY_HSUSBACT_Msk;

	/* Enable IP clock */
	CLK_EnableModuleClock(HSUSBD_MODULE);

	/******* this part for PDMA *****/
	/* Enable EPWM0 module clock */
	CLK_EnableModuleClock(EPWM0_MODULE);

	/* Select EPWM0 module clock source as PCLK0 */
	CLK_SetModuleClock(EPWM0_MODULE, CLK_CLKSEL2_EPWM0SEL_PCLK0, 0);

	/* Enable EADC module clock */
	CLK_EnableModuleClock(EADC_MODULE);

	/* EADC clock source is 96MHz, set divider to 8, EADC clock is 96/8 MHz */
	CLK_SetModuleClock(EADC_MODULE, 0, CLK_CLKDIV0_EADC(8));

	/* Enable PDMA clock source */
	CLK_EnableModuleClock(PDMA_MODULE);

	/* Set PB.0 ~ PB.15 to input mode */
	PB->MODE &= ~(GPIO_MODE_MODE0_Msk | GPIO_MODE_MODE1_Msk | GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk |
		GPIO_MODE_MODE4_Msk | GPIO_MODE_MODE5_Msk | GPIO_MODE_MODE6_Msk | GPIO_MODE_MODE7_Msk | 
		GPIO_MODE_MODE8_Msk |GPIO_MODE_MODE9_Msk | GPIO_MODE_MODE10_Msk | GPIO_MODE_MODE11_Msk | 
		GPIO_MODE_MODE12_Msk | GPIO_MODE_MODE13_Msk | GPIO_MODE_MODE14_Msk | GPIO_MODE_MODE15_Msk);
	/* Configure the GPB0 - GPB15 ADC analog input pins.  */
	SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk | SYS_GPB_MFPL_PB2MFP_Msk | SYS_GPB_MFPL_PB3MFP_Msk | 
		SYS_GPB_MFPL_PB4MFP_Msk | SYS_GPB_MFPL_PB5MFP_Msk | SYS_GPB_MFPL_PB6MFP_Msk | SYS_GPB_MFPL_PB7MFP_Msk |
		SYS_GPB_MFPH_PB8MFP_Msk | SYS_GPB_MFPH_PB9MFP_Msk | SYS_GPB_MFPH_PB10MFP_Msk | SYS_GPB_MFPH_PB11MFP_Msk |
		SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk | SYS_GPB_MFPH_PB14MFP_Msk | SYS_GPB_MFPH_PB15MFP_Msk);
	SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB0MFP_EADC0_CH0 | SYS_GPB_MFPL_PB1MFP_EADC0_CH1 | SYS_GPB_MFPL_PB2MFP_EADC0_CH2 | SYS_GPB_MFPL_PB3MFP_EADC0_CH3 |
		SYS_GPB_MFPL_PB4MFP_EADC0_CH4 | SYS_GPB_MFPL_PB5MFP_EADC0_CH5 | SYS_GPB_MFPL_PB6MFP_EADC0_CH6 | SYS_GPB_MFPL_PB7MFP_EADC0_CH7 |
		SYS_GPB_MFPH_PB8MFP_EADC0_CH8 | SYS_GPB_MFPH_PB9MFP_EADC0_CH9 | SYS_GPB_MFPH_PB10MFP_EADC0_CH10 | SYS_GPB_MFPH_PB11MFP_EADC0_CH11 |
		SYS_GPB_MFPH_PB12MFP_EADC0_CH12 | SYS_GPB_MFPH_PB13MFP_EADC0_CH13 | SYS_GPB_MFPH_PB14MFP_EADC0_CH14 | SYS_GPB_MFPH_PB15MFP_EADC0_CH15);

	/* Disable the GPB0 - GPB15 digital input path to avoid the leakage current. */
	GPIO_DISABLE_DIGITAL_PATH(PB, BIT15|BIT14|BIT13|BIT12|BIT11|BIT10|BIT9|BIT8|BIT7|BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0);

	/* Enable I2C0 clock */
  CLK_EnableModuleClock(I2C0_MODULE);	
	/* Set I2C0 multi-function pins */
  SYS->GPC_MFPL = (SYS->GPC_MFPL & ~(SYS_GPC_MFPL_PC0MFP_Msk | SYS_GPC_MFPL_PC1MFP_Msk)) |
                    (SYS_GPC_MFPL_PC0MFP_I2C0_SDA | SYS_GPC_MFPL_PC1MFP_I2C0_SCL);
	/* I2C clock pin enable schmitt trigger */
	PC->SMTEN |= GPIO_SMTEN_SMTEN5_Msk;
}

void EPWM0_Init()
{

	/* Set EPWM0 timer clock prescaler */
	EPWM_SET_PRESCALER(EPWM0, 0, 0);

	/* Set up counter type */
	EPWM0->CTL1 &= ~EPWM_CTL1_CNTTYPE0_Msk;

	/* Set EPWM0 timer duty */
	EPWM_SET_CMR(EPWM0, 0, 108);

	/* Set EPWM0 timer period */ 
	EPWM_SET_CNR(EPWM0, 0, 216);

	/* EPWM period point trigger ADC enable */
	EPWM_EnableADCTrigger(EPWM0, 0, EPWM_TRG_ADC_EVEN_PERIOD);

	/* Set output level at zero, compare up, period(center) and compare down of specified channel */
	EPWM_SET_OUTPUT_LEVEL(EPWM0, BIT0, EPWM_OUTPUT_HIGH, EPWM_OUTPUT_LOW, EPWM_OUTPUT_NOTHING, EPWM_OUTPUT_NOTHING);

	/* Enable output of EPWM0 channel 0 */
	EPWM_EnableOutput(EPWM0, BIT0);
}

void PDMA_Init()
{

	/* Configure PDMA peripheral mode form EADC to memory */
	/* Open Channel */
	PDMA_Open(PDMA,BIT2);

	/* transfer width is half word(16 bit) and transfer count is 1 */
	PDMA_SetTransferCnt(PDMA,2, PDMA_WIDTH_16, 1);

	/* Set source address as EADC data register(no increment) and destination address as g_i32ConversionData array(increment) */
	conversionAddress = (uint32_t) g_i32ConversionData;
	PDMA_SetTransferAddr(PDMA,2, (uint32_t)&EADC->DAT[g_u32SampleModuleNum], PDMA_SAR_FIX, conversionAddress, PDMA_DAR_INC);

	/* Select PDMA request source as ADC RX */
	PDMA_SetTransferMode(PDMA,2, PDMA_ADC_RX, FALSE, 0);

	/* Set PDMA as single request type for EADC */
	PDMA_SetBurstType(PDMA,2, PDMA_REQ_SINGLE, PDMA_BURST_4);

	PDMA_EnableInt(PDMA,2, PDMA_INT_TRANS_DONE);
	NVIC_EnableIRQ(PDMA_IRQn);

}

void ReloadPDMA()
{
	/* transfer width is half word(16 bit) and transfer count is 1 */
	PDMA_SetTransferCnt(PDMA,2, PDMA_WIDTH_16, 1);
	
	/* Set source address as EADC data register(no increment) and destination address as g_i32ConversionData array(increment) */
	PDMA_SetTransferAddr(PDMA,2, (uint32_t)&EADC->DAT[g_u32SampleModuleNum], PDMA_SAR_FIX, conversionAddress, PDMA_DAR_INC);
	
	/* Select PDMA request source as ADC RX */
	PDMA_SetTransferMode(PDMA,2, PDMA_ADC_RX, FALSE, 0);

	conversionAddress += 2;
}

void EADC_FunctionTest(int channel)
{
	/******* This part is copied from EADC_PDMA_EPWM_Trigger   **********************************************************/
	ReloadPDMA();
	/* Configure the sample module 0 for analog input channel and enable EPWM0 trigger source */
	EADC_ConfigSampleModule(EADC, g_u32SampleModuleNum, EADC_PWM0TG0_TRIGGER, channel);
	EADC_ENABLE_PDMA(EADC);

	/* Enable EPWM0 channel 0 counter */
	EPWM_Start(EPWM0, BIT0); /* EPWM0 channel 0 counter start running. */

	while(1)
	{
		/* Wait PDMA interrupt (g_u32IsTestOver will be set at IRQ_Handler function) */
		while(g_u32IsTestOver == 0);
		break;
	}
	g_u32IsTestOver = 0;

	/* Disable EPWM0 channel 0 counter */
	EPWM_ForceStop(EPWM0, BIT0); /* EPWM0 counter stop running. */

	/************************************************************************************/
}

void set_EADC_channel(uint16_t channel_hex)
{
	int8_t i;
	
	*(uint16_t*)conversionAddress=time_tag;
	conversionAddress += 2;
	for(i=9;i<16;i++)
	{
		if((channel_hex>>i)&0x01)
			EADC_FunctionTest(i-8);   //Read EADC value and write to SRAM
		else
			conversionAddress += 2;
	}
	for(i=0;i<8;i++)
	{
		if((channel_hex>>i)&0x01)
			EADC_FunctionTest(i+8);   //Read EADC value and write to SRAM
		else
			conversionAddress += 2;
	}
}

void PDMA_IRQHandler(void)
{
	uint32_t status = PDMA_GET_INT_STATUS(PDMA);

	if(status & PDMA_INTSTS_ABTIF_Msk)    /* abort */
	{
		if(PDMA_GET_ABORT_STS(PDMA) & PDMA_ABTSTS_ABTIF2_Msk)
			g_u32IsTestOver = 2;
		PDMA_CLR_ABORT_FLAG(PDMA,PDMA_ABTSTS_ABTIF2_Msk);
	}
	else if(status & PDMA_INTSTS_TDIF_Msk)      /* done */
	{
		if(PDMA_GET_TD_STS(PDMA) & PDMA_TDSTS_TDIF2_Msk)
			g_u32IsTestOver = 1;
		PDMA_CLR_TD_FLAG(PDMA,PDMA_TDSTS_TDIF2_Msk);
	}
	else
		printf("unknown interrupt !!\n");
}


void format()
{
	int i=0;
	char *address=(char*)0x20002300;	
	/*char fat32_table[512]=
	{
		0xEB ,0x3C ,0x90 ,0x4D ,0x53 ,0x44 ,0x4F ,0x53 ,0x35 ,0x2E ,0x30 ,0x00 ,0x02 ,0x01 ,0x06 ,0x00 , 
		0x02 ,0x00 ,0x02 ,0x28 ,0x00 ,0xF8 ,0x01 ,0x00 ,0x01 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 , 
		0x00 ,0x00 ,0x00 ,0x00 ,0x80 ,0x00 ,0x29 ,0xF3 ,0x0F ,0x14 ,0xBA ,0x4E ,0x4F ,0x20 ,0x4E ,0x41 ,
		0x4D ,0x45 ,0x20 ,0x20 ,0x20 ,0x20 ,0x46 ,0x41 ,0x54 ,0x31 ,0x32 ,0x20 ,0x20 ,0x20 ,0x33 ,0xC9 ,
		0x8E ,0xD1 ,0xBC ,0xF0 ,0x7B ,0x8E ,0xD9 ,0xB8 ,0x00 ,0x20 ,0x8E ,0xC0 ,0xFC ,0xBD ,0x00 ,0x7C ,
		0x38 ,0x4E ,0x24 ,0x7D ,0x24 ,0x8B ,0xC1 ,0x99 ,0xE8 ,0x3C ,0x01 ,0x72 ,0x1C ,0x83 ,0xEB ,0x3A ,
		0x66 ,0xA1 ,0x1C ,0x7C ,0x26 ,0x66 ,0x3B ,0x07 ,0x26 ,0x8A ,0x57 ,0xFC ,0x75 ,0x06 ,0x80 ,0xCA ,
		0x02 ,0x88 ,0x56 ,0x02 ,0x80 ,0xC3 ,0x10 ,0x73 ,0xEB ,0x33 ,0xC9 ,0x8A ,0x46 ,0x10 ,0x98 ,0xF7 ,
		0x66 ,0x16 ,0x03 ,0x46 ,0x1C ,0x13 ,0x56 ,0x1E ,0x03 ,0x46 ,0x0E ,0x13 ,0xD1 ,0x8B ,0x76 ,0x11 ,
		0x60 ,0x89 ,0x46 ,0xFC ,0x89 ,0x56 ,0xFE ,0xB8 ,0x20 ,0x00 ,0xF7 ,0xE6 ,0x8B ,0x5E ,0x0B ,0x03 ,
		0xC3 ,0x48 ,0xF7 ,0xF3 ,0x01 ,0x46 ,0xFC ,0x11 ,0x4E ,0xFE ,0x61 ,0xBF ,0x00 ,0x00 ,0xE8 ,0xE6 ,
		0x00 ,0x72 ,0x39 ,0x26 ,0x38 ,0x2D ,0x74 ,0x17 ,0x60 ,0xB1 ,0x0B ,0xBE ,0xA1 ,0x7D ,0xF3 ,0xA6 ,
		0x61 ,0x74 ,0x32 ,0x4E ,0x74 ,0x09 ,0x83 ,0xC7 ,0x20 ,0x3B ,0xFB ,0x72 ,0xE6 ,0xEB ,0xDC ,0xA0 ,
		0xFB ,0x7D ,0xB4 ,0x7D ,0x8B ,0xF0 ,0xAC ,0x98 ,0x40 ,0x74 ,0x0C ,0x48 ,0x74 ,0x13 ,0xB4 ,0x0E ,
		0xBB ,0x07 ,0x00 ,0xCD ,0x10 ,0xEB ,0xEF ,0xA0 ,0xFD ,0x7D ,0xEB ,0xE6 ,0xA0 ,0xFC ,0x7D ,0xEB ,
		0xE1 ,0xCD ,0x16 ,0xCD ,0x19 ,0x26 ,0x8B ,0x55 ,0x1A ,0x52 ,0xB0 ,0x01 ,0xBB ,0x00 ,0x00 ,0xE8 ,
		0x3B ,0x00 ,0x72 ,0xE8 ,0x5B ,0x8A ,0x56 ,0x24 ,0xBE ,0x0B ,0x7C ,0x8B ,0xFC ,0xC7 ,0x46 ,0xF0 ,
		0x3D ,0x7D ,0xC7 ,0x46 ,0xF4 ,0x29 ,0x7D ,0x8C ,0xD9 ,0x89 ,0x4E ,0xF2 ,0x89 ,0x4E ,0xF6 ,0xC6 ,
		0x06 ,0x96 ,0x7D ,0xCB ,0xEA ,0x03 ,0x00 ,0x00 ,0x20 ,0x0F ,0xB6 ,0xC8 ,0x66 ,0x8B ,0x46 ,0xF8 ,
		0x66 ,0x03 ,0x46 ,0x1C ,0x66 ,0x8B ,0xD0 ,0x66 ,0xC1 ,0xEA ,0x10 ,0xEB ,0x5E ,0x0F ,0xB6 ,0xC8 ,
		0x4A ,0x4A ,0x8A ,0x46 ,0x0D ,0x32 ,0xE4 ,0xF7 ,0xE2 ,0x03 ,0x46 ,0xFC ,0x13 ,0x56 ,0xFE ,0xEB ,
		0x4A ,0x52 ,0x50 ,0x06 ,0x53 ,0x6A ,0x01 ,0x6A ,0x10 ,0x91 ,0x8B ,0x46 ,0x18 ,0x96 ,0x92 ,0x33 ,
		0xD2 ,0xF7 ,0xF6 ,0x91 ,0xF7 ,0xF6 ,0x42 ,0x87 ,0xCA ,0xF7 ,0x76 ,0x1A ,0x8A ,0xF2 ,0x8A ,0xE8 ,
		0xC0 ,0xCC ,0x02 ,0x0A ,0xCC ,0xB8 ,0x01 ,0x02 ,0x80 ,0x7E ,0x02 ,0x0E ,0x75 ,0x04 ,0xB4 ,0x42 ,
		0x8B ,0xF4 ,0x8A ,0x56 ,0x24 ,0xCD ,0x13 ,0x61 ,0x61 ,0x72 ,0x0B ,0x40 ,0x75 ,0x01 ,0x42 ,0x03 ,
		0x5E ,0x0B ,0x49 ,0x75 ,0x06 ,0xF8 ,0xC3 ,0x41 ,0xBB ,0x00 ,0x00 ,0x60 ,0x66 ,0x6A ,0x00 ,0xEB ,
		0xB0 ,0x42 ,0x4F ,0x4F ,0x54 ,0x4D ,0x47 ,0x52 ,0x20 ,0x20 ,0x20 ,0x20 ,0x0D ,0x0A ,0x52 ,0x65 ,
		0x6D ,0x6F ,0x76 ,0x65 ,0x20 ,0x64 ,0x69 ,0x73 ,0x6B ,0x73 ,0x20 ,0x6F ,0x72 ,0x20 ,0x6F ,0x74 ,
		0x68 ,0x65 ,0x72 ,0x20 ,0x6D ,0x65 ,0x64 ,0x69 ,0x61 ,0x2E ,0xFF ,0x0D ,0x0A ,0x44 ,0x69 ,0x73 ,
		0x6B ,0x20 ,0x65 ,0x72 ,0x72 ,0x6F ,0x72 ,0xFF ,0x0D ,0x0A ,0x50 ,0x72 ,0x65 ,0x73 ,0x73 ,0x20 ,
		0x61 ,0x6E ,0x79 ,0x20 ,0x6B ,0x65 ,0x79 ,0x20 ,0x74 ,0x6F ,0x20 ,0x72 ,0x65 ,0x73 ,0x74 ,0x61 ,
		0x72 ,0x74 ,0x0D ,0x0A ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xAC ,0xCB ,0xD8 ,0x55 ,0xAA
	};*/
	char fat32_table[512]=
	{
		 0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x06, 0x00, 
		 0x02, 0x00, 0x02, 0x40, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
		 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x3E, 0x81, 0x6C, 0x4A, 0x4E, 0x4F, 0x20, 0x4E, 0x41, 
		 0x4D, 0x45, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x33, 0xC9, 
		 0x8E, 0xD1, 0xBC, 0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E, 0xC0, 0xFC, 0xBD, 0x00, 0x7C, 
		 0x38, 0x4E, 0x24, 0x7D, 0x24, 0x8B, 0xC1, 0x99, 0xE8, 0x3C, 0x01, 0x72, 0x1C, 0x83, 0xEB, 0x3A, 
		 0x66, 0xA1, 0x1C, 0x7C, 0x26, 0x66, 0x3B, 0x07, 0x26, 0x8A, 0x57, 0xFC, 0x75, 0x06, 0x80, 0xCA, 
		 0x02, 0x88, 0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xEB, 0x33, 0xC9, 0x8A, 0x46, 0x10, 0x98, 0xF7, 
		 0x66, 0x16, 0x03, 0x46, 0x1C, 0x13, 0x56, 0x1E, 0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11, 
		 0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8, 0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03, 
		 0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 0x4E, 0xFE, 0x61, 0xBF, 0x00, 0x00, 0xE8, 0xE6, 
		 0x00, 0x72, 0x39, 0x26, 0x38, 0x2D, 0x74, 0x17, 0x60, 0xB1, 0x0B, 0xBE, 0xA1, 0x7D, 0xF3, 0xA6, 
		 0x61, 0x74, 0x32, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 0x3B, 0xFB, 0x72, 0xE6, 0xEB, 0xDC, 0xA0, 
		 0xFB, 0x7D, 0xB4, 0x7D, 0x8B, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E, 
		 0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xEF, 0xA0, 0xFD, 0x7D, 0xEB, 0xE6, 0xA0, 0xFC, 0x7D, 0xEB, 
		 0xE1, 0xCD, 0x16, 0xCD, 0x19, 0x26, 0x8B, 0x55, 0x1A, 0x52, 0xB0, 0x01, 0xBB, 0x00, 0x00, 0xE8, 
		 0x3B, 0x00, 0x72, 0xE8, 0x5B, 0x8A, 0x56, 0x24, 0xBE, 0x0B, 0x7C, 0x8B, 0xFC, 0xC7, 0x46, 0xF0, 
		 0x3D, 0x7D, 0xC7, 0x46, 0xF4, 0x29, 0x7D, 0x8C, 0xD9, 0x89, 0x4E, 0xF2, 0x89, 0x4E, 0xF6, 0xC6, 
		 0x06, 0x96, 0x7D, 0xCB, 0xEA, 0x03, 0x00, 0x00, 0x20, 0x0F, 0xB6, 0xC8, 0x66, 0x8B, 0x46, 0xF8, 
		 0x66, 0x03, 0x46, 0x1C, 0x66, 0x8B, 0xD0, 0x66, 0xC1, 0xEA, 0x10, 0xEB, 0x5E, 0x0F, 0xB6, 0xC8, 
		 0x4A, 0x4A, 0x8A, 0x46, 0x0D, 0x32, 0xE4, 0xF7, 0xE2, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xEB, 
		 0x4A, 0x52, 0x50, 0x06, 0x53, 0x6A, 0x01, 0x6A, 0x10, 0x91, 0x8B, 0x46, 0x18, 0x96, 0x92, 0x33, 
		 0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 0x87, 0xCA, 0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8, 
		 0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 0x02, 0x80, 0x7E, 0x02, 0x0E, 0x75, 0x04, 0xB4, 0x42, 
		 0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 0x61, 0x61, 0x72, 0x0B, 0x40, 0x75, 0x01, 0x42, 0x03, 
		 0x5E, 0x0B, 0x49, 0x75, 0x06, 0xF8, 0xC3, 0x41, 0xBB, 0x00, 0x00, 0x60, 0x66, 0x6A, 0x00, 0xEB, 
		 0xB0, 0x42, 0x4F, 0x4F, 0x54, 0x4D, 0x47, 0x52, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x52, 0x65, 
		 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 
		 0x68, 0x65, 0x72, 0x20, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73, 
		 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 
		 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x74, 0x61, 
		 0x72, 0x74, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xCB, 0xD8, 0x55, 0xAA
	};
	
	for(i=0;i<512;i++)    //set fat32 table
	{
		*(address+i)=fat32_table[i];
	}
	for(i=512;i<30000;i++)    //clear mass storage sector 20480
	{
		*(address+i)=0x00;
	}
}

void format1()
{
	int i=0;
	char *address=(char*)0x20002F00;
	/*char c[512]=
	{
		0xf8,0xff,0xff,0xff,0x0f
	};*/
	char c[512]=
	{
		0xF8 ,0xFF ,0xFF ,0x03 ,0x40 ,0x00 ,0x05 ,0x60 ,0x00 ,0x07 ,0x80 ,0x00 ,0x09 ,0xA0 ,0x00 ,0x0B, 
		0xC0 ,0x00 ,0x0D ,0xE0 ,0x00 ,0x0F ,0x00 ,0x01 ,0x11 ,0xF0 ,0xFF ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
	};
	
	for(i=0;i<32;i++)    //set boot record
	{
		*(address+i)=c[i];
	}
}

void format2()
{
	int i=0;
	char *address=(char*)0x20003100;
	/*char c[512]=
	{
		0xf8,0xff,0xff,0xff,0x0f
	};*/
		char c[512]=
	{
		0xF8 ,0xFF ,0xFF ,0x03 ,0x40 ,0x00 ,0x05 ,0x60 ,0x00 ,0x07 ,0x80 ,0x00 ,0x09 ,0xA0 ,0x00 ,0x0B, 
		0xC0 ,0x00 ,0x0D ,0xE0 ,0x00 ,0x0F ,0x00 ,0x01 ,0x11 ,0xF0 ,0xFF ,0x00 ,0x00 ,0x00 ,0x00 ,0x00
	};
	
	for(i=0;i<32;i++)    //set boot record
	{
		*(address+i)=c[i];
	}
}

void format3()
{
	int i=0;
	char *address=(char*)0x20003300;
	/*char c[512]=
	{
		0x4F,0x55,0x54,0x50,0x55,0x54,0x20,0x20 ,0x42 ,0x49 ,0x4E ,0x20 ,0x18 ,0x7A ,0xC2 ,0x56 ,
		0x1C,0x4D,0x1C,0x4D,0x00,0x00,0xB1,0x56 ,0x1C ,0x4D ,0x02 ,0x00 ,0x20 ,0x00 ,0x00 ,0x00
	};*/
	char c[512]=
	{
		0x4F ,0x55 ,0x54 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x42 ,0x49 ,0x4E ,0x20 ,0x18 ,0x5A ,0x00 ,0x6D, 
		0x1C ,0x4D ,0x1C ,0x4D ,0x00 ,0x00 ,0xF9 ,0x6C ,0x1C ,0x4D ,0x02 ,0x00 ,0x00 ,0x20 ,0x00 ,0x00
	};
	for(i=0;i<32;i++)    //set boot record
	{
		*(address+i)=c[i];
	}
}

void format4()
{
	int i=0;
	char *address=(char*)0x20007300;
	char c[512]=
	{
		0xAA,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0xFF,0x11,0x11,0x11,0x11,0x11,0x11,0xFF,
	};
	for(i=0;i<8192;i++)    //set boot record
	{
		*(address+i)=0xAA;
	}
}

void set_first_line()
{
	/*default channel set 0xFF,0xFF*/
	*(char*)DataAddress=0xFF;
	*(char*)(DataAddress+0x01)=0xFF;
	
	/*set EADC channel 0*/
	PDMA_SetTransferCnt(PDMA,2, PDMA_WIDTH_16, 1);
	PDMA_SetTransferAddr(PDMA,2, (uint32_t)&EADC->DAT[g_u32SampleModuleNum], PDMA_SAR_FIX, DataAddress+0x10, PDMA_DAR_INC);
	PDMA_SetTransferMode(PDMA,2, PDMA_ADC_RX, FALSE, 0);
	EADC_ConfigSampleModule(EADC, g_u32SampleModuleNum, EADC_PWM0TG0_TRIGGER, 0);
	EADC_ENABLE_PDMA(EADC);
	EPWM_Start(EPWM0, BIT0); 
	while(1)
	{
		while(g_u32IsTestOver == 0);
		break;
	}
	g_u32IsTestOver = 0;
	EPWM_ForceStop(EPWM0, BIT0);
}

int32_t main (void)
{
	uint8_t I2C_data[3];
	uint16_t channel_hex;

	SYS_Init();
	/* Lock protected registers */
	SYS_LockReg();
	/* Init UART to 115200-8n1 for print message */
	UART_Open(UART0, 115200);
	/* Init EPWM for EADC */
	EPWM0_Init();
	/* Init I2C0 */
	I2C_Open(I2C0, 100000);
	
	printf("M480 HSUSB Mass Storage\n");
	
	/*initial HSUSBD*/
	HSUSBD_Open(&gsHSInfo, MSC_ClassRequest, NULL);
	/* Endpoint configuration */
	MSC_Init();
	/*initial PDMA*/
	PDMA_Init();

	/* Enable USBD interrupt */
	NVIC_EnableIRQ(USBD20_IRQn);
	/*Set input mode as single-end and enable the A/D converter*/
	EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);

	while(1) 
	{
		if(HSUSBD_IS_ATTACHED())  //wait USB device plug in
		{
			HSUSBD_Start();
			break;
		}
	}
	
	format();    //wait mass storage formatformat();
	format1();
	format2();
	format3();
	format4();
	printf("mass storage init ok\n");
	
	/*I2C Write */
	I2C_data[0]=0x3F;  //Write command(0x30) + All channel(0x0F)
	I2C_data[1]=0x47;  //12bit ADC value : FFF_0~000_0
	I2C_data[2]=0x00;
	I2C_WriteMultiBytes(I2C0,0x47,I2C_data,3); //Write i2c data to DAC,address=0x47
	printf("I2C ok\n");
	
	delay_ms(10);
	set_first_line();  //set first line on EADC table
	
	while(1)
	{
		if(conversionAddress>=(DataAddress+0x2000))
			conversionAddress=DataAddress+0x20;
		
		channel_hex=*(uint16_t*)DataAddress;//get PC channel setting
		set_EADC_channel(channel_hex);//set EADC channel value
		
		if(time_tag>=65535)
			time_tag=0;
		else
			time_tag++;
		
		if(g_u8MscStart)
			MSC_ProcessCmd();
		//delay_us(100);
	}
	
	EADC_Close(EADC);
	/* Disable EADC IP clock */
	CLK_DisableModuleClock(EADC_MODULE);
	/* Disable EPWM0 IP clock */
	CLK_DisableModuleClock(EPWM0_MODULE);
	/* Disable PDMA clock source */
	CLK_DisableModuleClock(PDMA_MODULE);
	/* Disable PDMA Interrupt */
	NVIC_DisableIRQ(PDMA_IRQn);
}
